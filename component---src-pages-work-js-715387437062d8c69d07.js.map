{"version":3,"sources":["webpack:///./src/components/Project/index.js","webpack:///./src/pages/work.js","webpack:///./src/components/GridStatement/index.js","webpack:///./node_modules/intersection-observer/intersection-observer.js","webpack:///./src/components/SearchField/index.js","webpack:///./src/components/Toolbar/index.js"],"names":["Container","styled","div","withConfig","displayName","componentId","ImageContainer","TextContainer","Text","p","Base","props","react_default","a","createElement","gatsby_link_default","to","path","gatsby_image_default","sizes","image","title","graduate","ProjectGrid","spacing","big","breakpoints","mobile","Work","state","search","category","updateCategory","e","_this","setState","updateSearch","inputValue","target","value","toLowerCase","render","_this2","this","filteredCategory","data","allMarkdownRemark","edges","filter","_ref","project","node","projCategories","frontmatter","category2","push","category3","_i","length","indexOf","filteredSearch","shuffleArray","_ref2","work_Container","Helmet_default","Toolbar","SearchField","onChange","GridStatement","work","verb","noun","map","_ref3","childImageSharp","fields","slug","key","id","React","Component","query","StatementContainer","small","noBorderRight","smaller","OuterContainer","css","grads","pad","StatementText","h2","TheNext","Statement","react__WEBPACK_IMPORTED_MODULE_1___default","right","window","document","IntersectionObserverEntry","prototype","Object","defineProperty","get","intersectionRatio","registry","IntersectionObserver","THROTTLE_TIMEOUT","POLL_INTERVAL","USE_MUTATION_OBSERVER","observe","_observationTargets","some","item","element","nodeType","Error","_registerInstance","entry","_monitorIntersections","_checkForIntersections","unobserve","_unmonitorIntersections","_unregisterInstance","disconnect","takeRecords","records","_queuedEntries","slice","_initThresholds","opt_threshold","threshold","Array","isArray","sort","t","i","isNaN","_parseRootMargin","opt_rootMargin","margins","split","margin","parts","exec","parseFloat","unit","_monitoringIntersections","_monitoringInterval","setInterval","addEvent","_domObserver","MutationObserver","attributes","childList","characterData","subtree","clearInterval","removeEvent","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","top","bottom","left","width","height","forEach","targetRect","getBoundingClientRect","rootContainsTarget","_rootContainsTarget","oldEntry","intersectionRect","_computeTargetAndRootIntersection","newEntry","time","performance","now","boundingClientRect","rootBounds","_hasCrossedThreshold","isIntersecting","_callback","getComputedStyle","display","rect1","rect2","parent","getParentNode","atRoot","parentRect","parentComputedStyle","root","body","documentElement","overflow","Math","max","min","html","clientWidth","clientHeight","_expandRectByRootMargin","rect","_rootMarginValues","newRect","oldRatio","newRatio","thresholds","containsDeep","index","splice","targetArea","intersectionArea","Number","toFixed","callback","opt_options","fn","timeout","timer","options","bind","setTimeout","rootMargin","join","event","opt_useCapture","addEventListener","attachEvent","removeEventListener","detatchEvent","el","err","child","parentNode","host","Input","input","bigger","assign","type","placeholder","HeadroomWrapper","Headroom","disableInlineStyles","children"],"mappings":"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","file":"component---src-pages-work-js-715387437062d8c69d07.js","sourcesContent":["import React from 'react'\nimport styled from 'styled-components'\nimport Link from 'gatsby-link'\nimport Img from 'gatsby-image'\n\n/*\n  Base component\n  Copy this directory and rename to your choosing\n*/\n\n\n// styled components\nconst Container = styled.div`\n\n  border-right: 1px solid black;\n  border-bottom: 1px solid black;\n  height: 100%;\n  width: 100%;\n\n  @media (min-width: 1276px) {\n    max-width: 639px;\n  }\n\n  ${'' /* max-height: calc(50vh - ${spacing.bigger*2}px); */}\n\n  display: flex;\n  flex-direction: column;\n\n  img {\n    object-fit: cover;\n    width: 100%;\n  }\n`\n\nconst ImageContainer = styled.div`\n  padding: 8.2rem;\n`;\n\nconst TextContainer = styled.div`\n  display: flex;\n  padding: 1rem 1.5rem;\n\n  justify-content: space-between;\n  align-items: flex-end;\n`;\n\nconst Text = styled.p`\n  z-index: 4;\n  color: black;\n  max-width: 400px;\n\n  margin: 0.4rem;\n  font-size: 1.4rem;\n  line-height: 1.2;\n\n\n  &:first-of-type {\n    ${'' /* font-style: italic; */}\n    text-transform: uppercase;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow: hidden;\n    width: 100%;\n  }\n\n  &:last-of-type {\n    width: 100%;\n    text-align: right;\n  }\n`\n\n\n// component\nexport default function Base(props) {\n  return (\n    <Link to={props.path}>\n      <Container>\n\n        <ImageContainer>\n          <Img sizes={props.image} />\n        </ImageContainer>\n\n        <TextContainer>\n          <Text>{props.title}</Text>\n          <Text>{props.graduate}</Text>\n        </TextContainer>\n      </Container>\n    </Link>\n  )\n}\n","import React from 'react'\nimport Helmet from 'react-helmet'\nimport styled from 'styled-components'\nimport { graphql } from 'gatsby';\nimport { spacing, breakpoints, shuffleArray } from '../utils/constants'\n\nimport GridStatement from '../components/GridStatement'\nimport Project from '../components/Project'\nimport SearchField from '../components/SearchField'\nimport Toolbar from '../components/Toolbar'\nimport 'intersection-observer'\n\nconst Container = styled.div`\n  height: 100%;\n`\n\nconst ProjectGrid = styled.div`\n  display: grid;\n  margin-right: -1px;\n  padding: ${spacing.big + 2}px 0;\n\n\n  grid-template-columns: repeat(auto-fit, minmax(400px, 2fr));\n\n  @media (max-width: 813px) {\n    grid-template-columns: repeat(auto-fit, minmax(300px, 2fr));\n  }\n\n  @media (max-width: ${breakpoints.mobile}px) {\n    width: 100%;\n    grid-template-columns: repeat(auto-fit, 1fr);\n  }\n`\n\n// const FiltersContainer = styled.div`\n//   display: flex;\n//   flex: 1;\n//   justify-content: space-around;\n//   border-left: 1px solid black;\n// `\n\n// const StyledButton = styled.button`\n//   outline: none;\n//   border: none;\n//   text-transform: uppercase;\n//   background-color: transparent;\n// `\n\n// function FilterButton(props) {\n//   return(\n//     <StyledButton onClick={() => props.handleCategoryUpdate(props.category)}>\n//       {props.category || \"All\"}\n//     </StyledButton>\n//   )\n// }\n\n// page component\nexport default class Work extends React.Component {\n  state = {\n    search: \"\",\n    category: \"\"\n  }\n\n  updateCategory = (e) => {\n    this.setState({\n      category: e\n    })\n  }\n\n  updateSearch = (e) => {\n    let inputValue = e.target.value.toLowerCase() || \"\";\n\n    this.setState({\n      search: inputValue,\n    })\n  }\n\n  render() {\n    const projects = this.props.data.allMarkdownRemark.edges;\n\n    const filteredCategory = projects.filter(({node: project}) => {\n      let projCategories = [project.frontmatter.category];\n\n      if (project.frontmatter.category2)\n        projCategories.push(project.frontmatter.category2)\n      if (project.frontmatter.category3)\n        projCategories.push(project.frontmatter.category3)\n\n      for (let category of projCategories) {\n        if (category.indexOf(this.state.category) === -1 )\n          return false\n      }\n\n      return true;\n    });\n\n    const filteredSearch = shuffleArray(filteredCategory.filter(({ node: project }) => {\n      return project.frontmatter.graduate.toLowerCase().indexOf(this.state.search) !== -1 ||\n        project.frontmatter.title.toLowerCase().indexOf(this.state.search) !== -1;\n    }));\n\n\n    return (\n      <Container>\n\n        <Helmet title=\"THE NEXT | WORK\"/>\n\n        <Toolbar>\n          <SearchField\n            value={this.state.search}\n            onChange={this.updateSearch}\n          />\n\n          {/* <FiltersContainer>\n            <FilterButton handleCategoryUpdate={this.updateCategory} category=\"\" />\n            <FilterButton handleCategoryUpdate={this.updateCategory} category=\"UI/UX\" />\n            <FilterButton handleCategoryUpdate={this.updateCategory} category=\"Product Design\"/>\n            <FilterButton handleCategoryUpdate={this.updateCategory} category=\"Typography\" />\n            <FilterButton handleCategoryUpdate={this.updateCategory} category=\"Print\" />\n          </FiltersContainer> */}\n\n        </Toolbar>\n\n        <ProjectGrid>\n          <GridStatement \n            work\n            verb=\"Explore\"\n            noun=\"project\"\n          />\n\n          {filteredSearch.map(({ node: project }) => (\n            <Project\n              title={project.frontmatter.title}\n              image={project.frontmatter.image.childImageSharp.sizes}\n              path={project.fields.slug}\n              graduate={project.frontmatter.graduate}\n              key={project.id}\n            />\n          ))}\n        </ProjectGrid>\n\n      </Container>\n    )\n  }\n\n}\n\n// data query\nexport const query = graphql`\n  query WorkQuery {\n    allMarkdownRemark (filter: { fileAbsolutePath: {regex: \"/content/work/\"} } ) {\n      edges {\n        node {\n          id\n\n          fields {\n            slug\n          }\n          frontmatter {\n            title\n            graduate\n            category\n            category2\n            category3\n            image {\n              childImageSharp {\n                sizes(maxHeight: 300, maxWidth: 300, quality: 90, cropFocus: CENTER) {\n                  ...GatsbyImageSharpSizes\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`;\n","import React from 'react'\nimport styled, {css} from 'styled-components'\nimport { spacing, breakpoints } from '../../utils/constants.js'\n/*\n  Base component\n  Copy this directory and rename to your choosing\n*/\n\n\nconst StatementContainer = styled.div`\n  position: relative;\n  width: 100%;\n  height: 100%;\n  padding: ${spacing.small}px;\n  color: black;\n  min-height: 170px;\n\n  \n  border-bottom: 1px solid black;\n\n  ${props => !props.noBorderRight && \"border-right: 1px solid black;\"}\n\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n\n  &:hover .image {\n    opacity: 1;\n  }\n\n  @media (min-width: ${breakpoints.mobile}px) {\n    min-height: 220px;\n  }\n\n  @media (max-width: ${breakpoints.mobile}px) {\n    padding: 0 ${spacing.smaller}px;\n  }\n`\n\nconst OuterContainer = styled.div`\n\n\n  ${props => props.work && css`\n    @media (min-width: ${1614}px) {\n      grid-column: 1 / 3;\n    }\n\n    @media screen and (max-width: ${breakpoints.mobile} ) {\n      height: 30%;\n    }\n  `}\n\n  ${props => props.grads && css`\n      grid-column: 1 / 2;\n      grid-row: 1 / 4;\n  `}\n\n\n  width: 100%;\n  height: 100%;\n  flex: 1;\n  padding: ${props => props.pad ? spacing.smaller : 0};\n`\n\nconst StatementText = styled.h2`\n  text-transform: uppercase;\n  line-height: 1;\n  margin-top: 0;\n  margin-bottom: 0;\n  text-align: left;\n  z-index: 1;\n\n  @media (max-width: ${breakpoints.mobile}) {\n    font-size: 3rem;\n  }\n`\n\nconst TheNext = styled.h2`\n  position: relative;\n  text-transform: uppercase;\n  line-height: 1;\n  margin-top: 0;\n  margin-bottom: 0;\n  text-align: right;\n\n  @media (max-width: ${breakpoints.mobile}) {\n    font-size: 3rem;\n    line-height: 1;\n    margin-top: 0;\n    margin-bottom: 0;\n    top: auto;\n  }\n`\n\nexport default function Statement(props) {\n  return (\n    <OuterContainer {...props}>\n      <StatementContainer {...props}>\n        <StatementText>\n          {props.verb || \"Announcing\"}\n        </StatementText>\n\n        <TheNext right>\n          The Next\n          </TheNext>\n\n        <StatementText>\n          {props.noun || \"Gradshow\"}\n        </StatementText>\n      </StatementContainer>\n    </OuterContainer>\n  )\n}\n","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n\n(function(window, document) {\n'use strict';\n\n\n// Exits early if all IntersectionObserver and IntersectionObserverEntry\n// features are natively supported.\nif ('IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window &&\n    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n\n  // Minimal polyfill for Edge 15's lack of `isIntersecting`\n  // See: https://github.com/w3c/IntersectionObserver/issues/211\n  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n    Object.defineProperty(window.IntersectionObserverEntry.prototype,\n      'isIntersecting', {\n      get: function () {\n        return this.intersectionRatio > 0;\n      }\n    });\n  }\n  return;\n}\n\n\n/**\n * An IntersectionObserver registry. This registry exists to hold a strong\n * reference to IntersectionObserver instances currently observing a target\n * element. Without this registry, instances without another reference may be\n * garbage collected.\n */\nvar registry = [];\n\n\n/**\n * Creates the global IntersectionObserverEntry constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n * @param {Object} entry A dictionary of instance properties.\n * @constructor\n */\nfunction IntersectionObserverEntry(entry) {\n  this.time = entry.time;\n  this.target = entry.target;\n  this.rootBounds = entry.rootBounds;\n  this.boundingClientRect = entry.boundingClientRect;\n  this.intersectionRect = entry.intersectionRect || getEmptyRect();\n  this.isIntersecting = !!entry.intersectionRect;\n\n  // Calculates the intersection ratio.\n  var targetRect = this.boundingClientRect;\n  var targetArea = targetRect.width * targetRect.height;\n  var intersectionRect = this.intersectionRect;\n  var intersectionArea = intersectionRect.width * intersectionRect.height;\n\n  // Sets intersection ratio.\n  if (targetArea) {\n    // Round the intersection ratio to avoid floating point math issues:\n    // https://github.com/w3c/IntersectionObserver/issues/324\n    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));\n  } else {\n    // If area is zero and is intersecting, sets to 1, otherwise to 0\n    this.intersectionRatio = this.isIntersecting ? 1 : 0;\n  }\n}\n\n\n/**\n * Creates the global IntersectionObserver constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n * @param {Function} callback The function to be invoked after intersection\n *     changes have queued. The function is not invoked if the queue has\n *     been emptied by calling the `takeRecords` method.\n * @param {Object=} opt_options Optional configuration options.\n * @constructor\n */\nfunction IntersectionObserver(callback, opt_options) {\n\n  var options = opt_options || {};\n\n  if (typeof callback != 'function') {\n    throw new Error('callback must be a function');\n  }\n\n  if (options.root && options.root.nodeType != 1) {\n    throw new Error('root must be an Element');\n  }\n\n  // Binds and throttles `this._checkForIntersections`.\n  this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n  // Private properties.\n  this._callback = callback;\n  this._observationTargets = [];\n  this._queuedEntries = [];\n  this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n  // Public properties.\n  this.thresholds = this._initThresholds(options.threshold);\n  this.root = options.root || null;\n  this.rootMargin = this._rootMarginValues.map(function(margin) {\n    return margin.value + margin.unit;\n  }).join(' ');\n}\n\n\n/**\n * The minimum interval within which the document will be checked for\n * intersection changes.\n */\nIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n/**\n * The frequency in which the polyfill polls for intersection changes.\n * this can be updated on a per instance basis and must be set prior to\n * calling `observe` on the first target.\n */\nIntersectionObserver.prototype.POLL_INTERVAL = null;\n\n/**\n * Use a mutation observer on the root element\n * to detect intersection changes.\n */\nIntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n\n\n/**\n * Starts observing a target element for intersection changes based on\n * the thresholds values.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.observe = function(target) {\n  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n    return item.element == target;\n  });\n\n  if (isTargetAlreadyObserved) {\n    return;\n  }\n\n  if (!(target && target.nodeType == 1)) {\n    throw new Error('target must be an Element');\n  }\n\n  this._registerInstance();\n  this._observationTargets.push({element: target, entry: null});\n  this._monitorIntersections();\n  this._checkForIntersections();\n};\n\n\n/**\n * Stops observing a target element for intersection changes.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.unobserve = function(target) {\n  this._observationTargets =\n      this._observationTargets.filter(function(item) {\n\n    return item.element != target;\n  });\n  if (!this._observationTargets.length) {\n    this._unmonitorIntersections();\n    this._unregisterInstance();\n  }\n};\n\n\n/**\n * Stops observing all target elements for intersection changes.\n */\nIntersectionObserver.prototype.disconnect = function() {\n  this._observationTargets = [];\n  this._unmonitorIntersections();\n  this._unregisterInstance();\n};\n\n\n/**\n * Returns any queue entries that have not yet been reported to the\n * callback and clears the queue. This can be used in conjunction with the\n * callback to obtain the absolute most up-to-date intersection information.\n * @return {Array} The currently queued entries.\n */\nIntersectionObserver.prototype.takeRecords = function() {\n  var records = this._queuedEntries.slice();\n  this._queuedEntries = [];\n  return records;\n};\n\n\n/**\n * Accepts the threshold value from the user configuration object and\n * returns a sorted array of unique threshold values. If a value is not\n * between 0 and 1 and error is thrown.\n * @private\n * @param {Array|number=} opt_threshold An optional threshold value or\n *     a list of threshold values, defaulting to [0].\n * @return {Array} A sorted list of unique and valid threshold values.\n */\nIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n  var threshold = opt_threshold || [0];\n  if (!Array.isArray(threshold)) threshold = [threshold];\n\n  return threshold.sort().filter(function(t, i, a) {\n    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n      throw new Error('threshold must be a number between 0 and 1 inclusively');\n    }\n    return t !== a[i - 1];\n  });\n};\n\n\n/**\n * Accepts the rootMargin value from the user configuration object\n * and returns an array of the four margin values as an object containing\n * the value and unit properties. If any of the values are not properly\n * formatted or use a unit other than px or %, and error is thrown.\n * @private\n * @param {string=} opt_rootMargin An optional rootMargin value,\n *     defaulting to '0px'.\n * @return {Array<Object>} An array of margin objects with the keys\n *     value and unit.\n */\nIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n  var marginString = opt_rootMargin || '0px';\n  var margins = marginString.split(/\\s+/).map(function(margin) {\n    var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n    if (!parts) {\n      throw new Error('rootMargin must be specified in pixels or percent');\n    }\n    return {value: parseFloat(parts[1]), unit: parts[2]};\n  });\n\n  // Handles shorthand.\n  margins[1] = margins[1] || margins[0];\n  margins[2] = margins[2] || margins[0];\n  margins[3] = margins[3] || margins[1];\n\n  return margins;\n};\n\n\n/**\n * Starts polling for intersection changes if the polling is not already\n * happening, and if the page's visibility state is visible.\n * @private\n */\nIntersectionObserver.prototype._monitorIntersections = function() {\n  if (!this._monitoringIntersections) {\n    this._monitoringIntersections = true;\n\n    // If a poll interval is set, use polling instead of listening to\n    // resize and scroll events or DOM mutations.\n    if (this.POLL_INTERVAL) {\n      this._monitoringInterval = setInterval(\n          this._checkForIntersections, this.POLL_INTERVAL);\n    }\n    else {\n      addEvent(window, 'resize', this._checkForIntersections, true);\n      addEvent(document, 'scroll', this._checkForIntersections, true);\n\n      if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n        this._domObserver = new MutationObserver(this._checkForIntersections);\n        this._domObserver.observe(document, {\n          attributes: true,\n          childList: true,\n          characterData: true,\n          subtree: true\n        });\n      }\n    }\n  }\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @private\n */\nIntersectionObserver.prototype._unmonitorIntersections = function() {\n  if (this._monitoringIntersections) {\n    this._monitoringIntersections = false;\n\n    clearInterval(this._monitoringInterval);\n    this._monitoringInterval = null;\n\n    removeEvent(window, 'resize', this._checkForIntersections, true);\n    removeEvent(document, 'scroll', this._checkForIntersections, true);\n\n    if (this._domObserver) {\n      this._domObserver.disconnect();\n      this._domObserver = null;\n    }\n  }\n};\n\n\n/**\n * Scans each observation target for intersection changes and adds them\n * to the internal entries queue. If new entries are found, it\n * schedules the callback to be invoked.\n * @private\n */\nIntersectionObserver.prototype._checkForIntersections = function() {\n  var rootIsInDom = this._rootIsInDom();\n  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n  this._observationTargets.forEach(function(item) {\n    var target = item.element;\n    var targetRect = getBoundingClientRect(target);\n    var rootContainsTarget = this._rootContainsTarget(target);\n    var oldEntry = item.entry;\n    var intersectionRect = rootIsInDom && rootContainsTarget &&\n        this._computeTargetAndRootIntersection(target, rootRect);\n\n    var newEntry = item.entry = new IntersectionObserverEntry({\n      time: now(),\n      target: target,\n      boundingClientRect: targetRect,\n      rootBounds: rootRect,\n      intersectionRect: intersectionRect\n    });\n\n    if (!oldEntry) {\n      this._queuedEntries.push(newEntry);\n    } else if (rootIsInDom && rootContainsTarget) {\n      // If the new entry intersection ratio has crossed any of the\n      // thresholds, add a new entry.\n      if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n        this._queuedEntries.push(newEntry);\n      }\n    } else {\n      // If the root is not in the DOM or target is not contained within\n      // root but the previous entry for this target had an intersection,\n      // add a new record indicating removal.\n      if (oldEntry && oldEntry.isIntersecting) {\n        this._queuedEntries.push(newEntry);\n      }\n    }\n  }, this);\n\n  if (this._queuedEntries.length) {\n    this._callback(this.takeRecords(), this);\n  }\n};\n\n\n/**\n * Accepts a target and root rect computes the intersection between then\n * following the algorithm in the spec.\n * TODO(philipwalton): at this time clip-path is not considered.\n * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n * @param {Element} target The target DOM element\n * @param {Object} rootRect The bounding rect of the root after being\n *     expanded by the rootMargin value.\n * @return {?Object} The final intersection rect object or undefined if no\n *     intersection is found.\n * @private\n */\nIntersectionObserver.prototype._computeTargetAndRootIntersection =\n    function(target, rootRect) {\n\n  // If the element isn't displayed, an intersection can't happen.\n  if (window.getComputedStyle(target).display == 'none') return;\n\n  var targetRect = getBoundingClientRect(target);\n  var intersectionRect = targetRect;\n  var parent = getParentNode(target);\n  var atRoot = false;\n\n  while (!atRoot) {\n    var parentRect = null;\n    var parentComputedStyle = parent.nodeType == 1 ?\n        window.getComputedStyle(parent) : {};\n\n    // If the parent isn't displayed, an intersection can't happen.\n    if (parentComputedStyle.display == 'none') return;\n\n    if (parent == this.root || parent == document) {\n      atRoot = true;\n      parentRect = rootRect;\n    } else {\n      // If the element has a non-visible overflow, and it's not the <body>\n      // or <html> element, update the intersection rect.\n      // Note: <body> and <html> cannot be clipped to a rect that's not also\n      // the document rect, so no need to compute a new intersection.\n      if (parent != document.body &&\n          parent != document.documentElement &&\n          parentComputedStyle.overflow != 'visible') {\n        parentRect = getBoundingClientRect(parent);\n      }\n    }\n\n    // If either of the above conditionals set a new parentRect,\n    // calculate new intersection data.\n    if (parentRect) {\n      intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n\n      if (!intersectionRect) break;\n    }\n    parent = getParentNode(parent);\n  }\n  return intersectionRect;\n};\n\n\n/**\n * Returns the root rect after being expanded by the rootMargin value.\n * @return {Object} The expanded root rect.\n * @private\n */\nIntersectionObserver.prototype._getRootRect = function() {\n  var rootRect;\n  if (this.root) {\n    rootRect = getBoundingClientRect(this.root);\n  } else {\n    // Use <html>/<body> instead of window since scroll bars affect size.\n    var html = document.documentElement;\n    var body = document.body;\n    rootRect = {\n      top: 0,\n      left: 0,\n      right: html.clientWidth || body.clientWidth,\n      width: html.clientWidth || body.clientWidth,\n      bottom: html.clientHeight || body.clientHeight,\n      height: html.clientHeight || body.clientHeight\n    };\n  }\n  return this._expandRectByRootMargin(rootRect);\n};\n\n\n/**\n * Accepts a rect and expands it by the rootMargin value.\n * @param {Object} rect The rect object to expand.\n * @return {Object} The expanded rect.\n * @private\n */\nIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n  var margins = this._rootMarginValues.map(function(margin, i) {\n    return margin.unit == 'px' ? margin.value :\n        margin.value * (i % 2 ? rect.width : rect.height) / 100;\n  });\n  var newRect = {\n    top: rect.top - margins[0],\n    right: rect.right + margins[1],\n    bottom: rect.bottom + margins[2],\n    left: rect.left - margins[3]\n  };\n  newRect.width = newRect.right - newRect.left;\n  newRect.height = newRect.bottom - newRect.top;\n\n  return newRect;\n};\n\n\n/**\n * Accepts an old and new entry and returns true if at least one of the\n * threshold values has been crossed.\n * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n *    particular target element or null if no previous entry exists.\n * @param {IntersectionObserverEntry} newEntry The current entry for a\n *    particular target element.\n * @return {boolean} Returns true if a any threshold has been crossed.\n * @private\n */\nIntersectionObserver.prototype._hasCrossedThreshold =\n    function(oldEntry, newEntry) {\n\n  // To make comparing easier, an entry that has a ratio of 0\n  // but does not actually intersect is given a value of -1\n  var oldRatio = oldEntry && oldEntry.isIntersecting ?\n      oldEntry.intersectionRatio || 0 : -1;\n  var newRatio = newEntry.isIntersecting ?\n      newEntry.intersectionRatio || 0 : -1;\n\n  // Ignore unchanged ratios\n  if (oldRatio === newRatio) return;\n\n  for (var i = 0; i < this.thresholds.length; i++) {\n    var threshold = this.thresholds[i];\n\n    // Return true if an entry matches a threshold or if the new ratio\n    // and the old ratio are on the opposite sides of a threshold.\n    if (threshold == oldRatio || threshold == newRatio ||\n        threshold < oldRatio !== threshold < newRatio) {\n      return true;\n    }\n  }\n};\n\n\n/**\n * Returns whether or not the root element is an element and is in the DOM.\n * @return {boolean} True if the root element is an element and is in the DOM.\n * @private\n */\nIntersectionObserver.prototype._rootIsInDom = function() {\n  return !this.root || containsDeep(document, this.root);\n};\n\n\n/**\n * Returns whether or not the target element is a child of root.\n * @param {Element} target The target element to check.\n * @return {boolean} True if the target element is a child of root.\n * @private\n */\nIntersectionObserver.prototype._rootContainsTarget = function(target) {\n  return containsDeep(this.root || document, target);\n};\n\n\n/**\n * Adds the instance to the global IntersectionObserver registry if it isn't\n * already present.\n * @private\n */\nIntersectionObserver.prototype._registerInstance = function() {\n  if (registry.indexOf(this) < 0) {\n    registry.push(this);\n  }\n};\n\n\n/**\n * Removes the instance from the global IntersectionObserver registry.\n * @private\n */\nIntersectionObserver.prototype._unregisterInstance = function() {\n  var index = registry.indexOf(this);\n  if (index != -1) registry.splice(index, 1);\n};\n\n\n/**\n * Returns the result of the performance.now() method or null in browsers\n * that don't support the API.\n * @return {number} The elapsed time since the page was requested.\n */\nfunction now() {\n  return window.performance && performance.now && performance.now();\n}\n\n\n/**\n * Throttles a function and delays its execution, so it's only called at most\n * once within a given time period.\n * @param {Function} fn The function to throttle.\n * @param {number} timeout The amount of time that must pass before the\n *     function can be called again.\n * @return {Function} The throttled function.\n */\nfunction throttle(fn, timeout) {\n  var timer = null;\n  return function () {\n    if (!timer) {\n      timer = setTimeout(function() {\n        fn();\n        timer = null;\n      }, timeout);\n    }\n  };\n}\n\n\n/**\n * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n * @param {Node} node The DOM node to add the event handler to.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to add.\n * @param {boolean} opt_useCapture Optionally adds the even to the capture\n *     phase. Note: this only works in modern browsers.\n */\nfunction addEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.addEventListener == 'function') {\n    node.addEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.attachEvent == 'function') {\n    node.attachEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Removes a previously added event handler from a DOM node.\n * @param {Node} node The DOM node to remove the event handler from.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to remove.\n * @param {boolean} opt_useCapture If the event handler was added with this\n *     flag set to true, it should be set to true here in order to remove it.\n */\nfunction removeEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.removeEventListener == 'function') {\n    node.removeEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.detatchEvent == 'function') {\n    node.detatchEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Returns the intersection between two rect objects.\n * @param {Object} rect1 The first rect.\n * @param {Object} rect2 The second rect.\n * @return {?Object} The intersection rect or undefined if no intersection\n *     is found.\n */\nfunction computeRectIntersection(rect1, rect2) {\n  var top = Math.max(rect1.top, rect2.top);\n  var bottom = Math.min(rect1.bottom, rect2.bottom);\n  var left = Math.max(rect1.left, rect2.left);\n  var right = Math.min(rect1.right, rect2.right);\n  var width = right - left;\n  var height = bottom - top;\n\n  return (width >= 0 && height >= 0) && {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n\n\n/**\n * Shims the native getBoundingClientRect for compatibility with older IE.\n * @param {Element} el The element whose bounding rect to get.\n * @return {Object} The (possibly shimmed) rect of the element.\n */\nfunction getBoundingClientRect(el) {\n  var rect;\n\n  try {\n    rect = el.getBoundingClientRect();\n  } catch (err) {\n    // Ignore Windows 7 IE11 \"Unspecified error\"\n    // https://github.com/w3c/IntersectionObserver/pull/205\n  }\n\n  if (!rect) return getEmptyRect();\n\n  // Older IE\n  if (!(rect.width && rect.height)) {\n    rect = {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n  }\n  return rect;\n}\n\n\n/**\n * Returns an empty rect object. An empty rect is returned when an element\n * is not in the DOM.\n * @return {Object} The empty rect.\n */\nfunction getEmptyRect() {\n  return {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0\n  };\n}\n\n/**\n * Checks to see if a parent element contains a child element (including inside\n * shadow DOM).\n * @param {Node} parent The parent element.\n * @param {Node} child The child element.\n * @return {boolean} True if the parent node contains the child node.\n */\nfunction containsDeep(parent, child) {\n  var node = child;\n  while (node) {\n    if (node == parent) return true;\n\n    node = getParentNode(node);\n  }\n  return false;\n}\n\n\n/**\n * Gets the parent node of an element or its host element if the parent node\n * is a shadow root.\n * @param {Node} node The node whose parent to get.\n * @return {Node|null} The parent node or null if no parent exists.\n */\nfunction getParentNode(node) {\n  var parent = node.parentNode;\n\n  if (parent && parent.nodeType == 11 && parent.host) {\n    // If the parent is a shadow root, return the host element.\n    return parent.host;\n  }\n  return parent;\n}\n\n\n// Exposes the constructors globally.\nwindow.IntersectionObserver = IntersectionObserver;\nwindow.IntersectionObserverEntry = IntersectionObserverEntry;\n\n}(window, document));\n","import React from 'react'\nimport styled from 'styled-components'\nimport { spacing, breakpoints } from '../../utils/constants.js'\n\n/*\n  Base component\n  Copy this directory and rename to your choosing\n*/\n\n\n// styled components\nconst Input = styled.input`\n  outline: none;\n  background-color: none;\n  border: none;\n  width: 100%;\n  height: 100%;\n  text-transform: uppercase;\n  text-align: center;\n  height: ${spacing.bigger}px;\n  flex: 1;\n  padding-top: 4px;\n\n  @media (max-width: ${breakpoints.mobile}) {\n    padding-top: 7px;\n  }\n`;\n\n\n// component\nexport default function Base(props) {\n  return (\n    <Input \n      {...props} \n      type=\"text\"\n      placeholder=\"Search\"\n    />\n  )\n}\n","import React from 'react'\nimport styled from 'styled-components'\nimport { spacing, breakpoints } from '../../utils/constants.js'\nimport Headroom from 'react-headroom'\n\n/*\n  Base component\n  Copy this directory and rename to your choosing\n*/\n\nconst HeadroomWrapper = styled(Headroom)`\n  .headroom {\n    position: fixed;\n    left: 0;\n    right: 0;\n    z-index: 5;\n    transition: transform 200ms cubic-bezier(.14,.6,.36,1);\n  }\n  .headroom--unfixed {\n    transform: translateY(0);\n  }\n  .headroom--scrolled {\n    transition: transform 200ms cubic-bezier(.14,.6,.36,1);\n  }\n  .headroom--unpinned {\n    position: fixed;\n    transform: translateY(-${spacing.bigger + 1}px);\n  }\n  .headroom--pinned {\n    position: fixed;\n    transform: translateY(0%);\n  }\n\n`\n\n// styled components\nconst Container = styled.div`\n  width: 100%;\n\n  ${'' /* margin-top: -1px; */}\n  border-bottom: 1px solid black;\n  padding: 0 ${spacing.small}px;\n\n  display: flex;\n  position: fixed;\n  background-color: white;\n  z-index: 6;\n\n  @media (max-width: ${breakpoints.mobile}) {\n    flex-direction: column;\n    top: 2px;\n  }\n`\n\n// component\nexport default function Toolbar(props) {\n  return (\n    <HeadroomWrapper disableInlineStyles>\n      <Container>\n        {props.children}\n      </Container>\n    </HeadroomWrapper>\n  )\n}"],"sourceRoot":""}